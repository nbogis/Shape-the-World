<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SimpleLink Host Driver: Socket</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">SimpleLink Host Driver
   &#160;<span id="projectnumber">0.0.5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__socket.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Socket</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5c5aff109698b82357cd674ec8c992c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5c5aff109698b82357cd674ec8c992c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sl_Ntohl</b>&#160;&#160;&#160;<a class="el" href="group__socket.html#ga56e74657a9772b9ad9e5ac5697d10562">sl_Htonl</a>  /* Reorder the bytes of a 16-bit unsigned value from network order to processor orde. */</td></tr>
<tr class="separator:ga5c5aff109698b82357cd674ec8c992c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86db1a301e3e3f67de94193a1dff6e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac86db1a301e3e3f67de94193a1dff6e1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sl_Ntohs</b>&#160;&#160;&#160;<a class="el" href="group__socket.html#gada8288bc08f38860bd27cd5fd611e1ba">sl_Htons</a>   /* Reorder the bytes of a 16-bit unsigned value from network order to processor orde. */</td></tr>
<tr class="separator:gac86db1a301e3e3f67de94193a1dff6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4808ad2f0d41a2b38b3d753ce3b3dfe9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9">sl_Socket</a> (int Domain, int Type, int Protocol)</td></tr>
<tr class="memdesc:ga4808ad2f0d41a2b38b3d753ce3b3dfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an endpoint for communication  <a href="#ga4808ad2f0d41a2b38b3d753ce3b3dfe9">More...</a><br/></td></tr>
<tr class="separator:ga4808ad2f0d41a2b38b3d753ce3b3dfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc776f15d8e8d8a4662269dac8aca1fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#gabc776f15d8e8d8a4662269dac8aca1fc">sl_Close</a> (int sd)</td></tr>
<tr class="memdesc:gabc776f15d8e8d8a4662269dac8aca1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">gracefully close socket  <a href="#gabc776f15d8e8d8a4662269dac8aca1fc">More...</a><br/></td></tr>
<tr class="separator:gabc776f15d8e8d8a4662269dac8aca1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70d8c15542e4590d80cc9f9283f4b210"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga70d8c15542e4590d80cc9f9283f4b210">sl_Accept</a> (int sd, <a class="el" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *addr, SlSocklen_t *addrlen)</td></tr>
<tr class="memdesc:ga70d8c15542e4590d80cc9f9283f4b210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a connection on a socket.  <a href="#ga70d8c15542e4590d80cc9f9283f4b210">More...</a><br/></td></tr>
<tr class="separator:ga70d8c15542e4590d80cc9f9283f4b210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45b5395b4b2bdd6189998849537c7d86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga45b5395b4b2bdd6189998849537c7d86">sl_Bind</a> (int sd, const <a class="el" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *addr, int addrlen)</td></tr>
<tr class="memdesc:ga45b5395b4b2bdd6189998849537c7d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign a name to a socket  <a href="#ga45b5395b4b2bdd6189998849537c7d86">More...</a><br/></td></tr>
<tr class="separator:ga45b5395b4b2bdd6189998849537c7d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ea071794a86d677212d6ae5041b923"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga74ea071794a86d677212d6ae5041b923">sl_Listen</a> (int sd, int backlog)</td></tr>
<tr class="memdesc:ga74ea071794a86d677212d6ae5041b923"><td class="mdescLeft">&#160;</td><td class="mdescRight">listen for connections on a socket  <a href="#ga74ea071794a86d677212d6ae5041b923">More...</a><br/></td></tr>
<tr class="separator:ga74ea071794a86d677212d6ae5041b923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc00ba87f0cd7cbdbfca14394502a15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga2cc00ba87f0cd7cbdbfca14394502a15">sl_Connect</a> (int sd, const <a class="el" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *addr, int addrlen)</td></tr>
<tr class="memdesc:ga2cc00ba87f0cd7cbdbfca14394502a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a connection on a socket.  <a href="#ga2cc00ba87f0cd7cbdbfca14394502a15">More...</a><br/></td></tr>
<tr class="separator:ga2cc00ba87f0cd7cbdbfca14394502a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f5927fc693b19f6c1aab3110adc64b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga0f5927fc693b19f6c1aab3110adc64b1">sl_Select</a> (int nfds, <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *readsds, <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *writesds, <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *exceptsds, struct <a class="el" href="struct_sl_timeval__t.html">SlTimeval_t</a> *timeout)</td></tr>
<tr class="memdesc:ga0f5927fc693b19f6c1aab3110adc64b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monitor socket activity.  <a href="#ga0f5927fc693b19f6c1aab3110adc64b1">More...</a><br/></td></tr>
<tr class="separator:ga0f5927fc693b19f6c1aab3110adc64b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d4421250534b9bd4ac41b30f9cf06b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga25d4421250534b9bd4ac41b30f9cf06b">SL_FD_SET</a> (int fd, <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *fdset)</td></tr>
<tr class="memdesc:ga25d4421250534b9bd4ac41b30f9cf06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select's <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> SET function.  <a href="#ga25d4421250534b9bd4ac41b30f9cf06b">More...</a><br/></td></tr>
<tr class="separator:ga25d4421250534b9bd4ac41b30f9cf06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a4253cf994b2a796f730468abbe183"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#gac2a4253cf994b2a796f730468abbe183">SL_FD_CLR</a> (int fd, <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *fdset)</td></tr>
<tr class="memdesc:gac2a4253cf994b2a796f730468abbe183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select's <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> CLR function.  <a href="#gac2a4253cf994b2a796f730468abbe183">More...</a><br/></td></tr>
<tr class="separator:gac2a4253cf994b2a796f730468abbe183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de8eef8d39b4398d2e694dc88edd64e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga4de8eef8d39b4398d2e694dc88edd64e">SL_FD_ISSET</a> (int fd, <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *fdset)</td></tr>
<tr class="memdesc:ga4de8eef8d39b4398d2e694dc88edd64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select's <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> ISSET function.  <a href="#ga4de8eef8d39b4398d2e694dc88edd64e">More...</a><br/></td></tr>
<tr class="separator:ga4de8eef8d39b4398d2e694dc88edd64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac58eca56e2cf9bf58f8f3ef8790f7740"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#gac58eca56e2cf9bf58f8f3ef8790f7740">SL_FD_ZERO</a> (<a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *fdset)</td></tr>
<tr class="memdesc:gac58eca56e2cf9bf58f8f3ef8790f7740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select's <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> ZERO function.  <a href="#gac58eca56e2cf9bf58f8f3ef8790f7740">More...</a><br/></td></tr>
<tr class="separator:gac58eca56e2cf9bf58f8f3ef8790f7740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga173062c9a3a1ca728e651e98aedca7fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a> (int sd, int level, int optname, const void *optval, SlSocklen_t optlen)</td></tr>
<tr class="memdesc:ga173062c9a3a1ca728e651e98aedca7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">set socket options  <a href="#ga173062c9a3a1ca728e651e98aedca7fb">More...</a><br/></td></tr>
<tr class="separator:ga173062c9a3a1ca728e651e98aedca7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43f04e75d9ea0a29b4a4c58f29cfdd8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga43f04e75d9ea0a29b4a4c58f29cfdd8c">sl_GetSockOpt</a> (int sd, int level, int optname, void *optval, SlSocklen_t *optlen)</td></tr>
<tr class="memdesc:ga43f04e75d9ea0a29b4a4c58f29cfdd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket options.  <a href="#ga43f04e75d9ea0a29b4a4c58f29cfdd8c">More...</a><br/></td></tr>
<tr class="separator:ga43f04e75d9ea0a29b4a4c58f29cfdd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34256a8387b64d696c4a62ac1e282ee3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga34256a8387b64d696c4a62ac1e282ee3">sl_Recv</a> (int sd, void *buf, int Len, int flags)</td></tr>
<tr class="memdesc:ga34256a8387b64d696c4a62ac1e282ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">read data from TCP socket  <a href="#ga34256a8387b64d696c4a62ac1e282ee3">More...</a><br/></td></tr>
<tr class="separator:ga34256a8387b64d696c4a62ac1e282ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee942befd4fa36fdacab25adfba2434b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#gaee942befd4fa36fdacab25adfba2434b">sl_RecvFrom</a> (int sd, void *buf, int Len, int flags, <a class="el" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *from, SlSocklen_t *fromlen)</td></tr>
<tr class="memdesc:gaee942befd4fa36fdacab25adfba2434b"><td class="mdescLeft">&#160;</td><td class="mdescRight">read data from socket  <a href="#gaee942befd4fa36fdacab25adfba2434b">More...</a><br/></td></tr>
<tr class="separator:gaee942befd4fa36fdacab25adfba2434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24dfb00de85356d4ba18662177c2eec5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga24dfb00de85356d4ba18662177c2eec5">sl_Send</a> (int sd, const void *buf, int Len, int flags)</td></tr>
<tr class="memdesc:ga24dfb00de85356d4ba18662177c2eec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">write data to TCP socket  <a href="#ga24dfb00de85356d4ba18662177c2eec5">More...</a><br/></td></tr>
<tr class="separator:ga24dfb00de85356d4ba18662177c2eec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0936b748a4f6d7f1943920ec91a82120"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga0936b748a4f6d7f1943920ec91a82120">sl_SendTo</a> (int sd, const void *buf, int Len, int flags, const <a class="el" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *to, SlSocklen_t tolen)</td></tr>
<tr class="memdesc:ga0936b748a4f6d7f1943920ec91a82120"><td class="mdescLeft">&#160;</td><td class="mdescRight">write data to socket  <a href="#ga0936b748a4f6d7f1943920ec91a82120">More...</a><br/></td></tr>
<tr class="separator:ga0936b748a4f6d7f1943920ec91a82120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e74657a9772b9ad9e5ac5697d10562"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#ga56e74657a9772b9ad9e5ac5697d10562">sl_Htonl</a> (unsigned long val)</td></tr>
<tr class="memdesc:ga56e74657a9772b9ad9e5ac5697d10562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder the bytes of a 32-bit unsigned value.  <a href="#ga56e74657a9772b9ad9e5ac5697d10562">More...</a><br/></td></tr>
<tr class="separator:ga56e74657a9772b9ad9e5ac5697d10562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada8288bc08f38860bd27cd5fd611e1ba"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket.html#gada8288bc08f38860bd27cd5fd611e1ba">sl_Htons</a> (unsigned short val)</td></tr>
<tr class="memdesc:gada8288bc08f38860bd27cd5fd611e1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder the bytes of a 16-bit unsigned value.  <a href="#gada8288bc08f38860bd27cd5fd611e1ba">More...</a><br/></td></tr>
<tr class="separator:gada8288bc08f38860bd27cd5fd611e1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga70d8c15542e4590d80cc9f9283f4b210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sl_Accept </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlSocklen_t *&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a connection on a socket. </p>
<p>This function is used with connection-based socket types (SOCK_STREAM). It extracts the first connection request on the queue of pending connections, creates a new connected socket, and returns a new file descriptor referring to that socket. The newly created socket is not in the listening state. The original socket sd is unaffected by this call. The argument sd is a socket that has been created with <a class="el" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9" title="create an endpoint for communication ">sl_Socket()</a>, bound to a local address with <a class="el" href="group__socket.html#ga45b5395b4b2bdd6189998849537c7d86" title="assign a name to a socket ">sl_Bind()</a>, and is listening for connections after a <a class="el" href="group__socket.html#ga74ea071794a86d677212d6ae5041b923" title="listen for connections on a socket ">sl_Listen()</a>. The argument <b><em>addr</em> is</b> a pointer to a sockaddr structure. This structure is filled in with the address of the peer socket, as known to the communications layer. The exact format of the address returned addr is determined by the socket's address family. The <b><em>addrlen</em> argument</b> is a value-result argument: it should initially contain the size of the structure pointed to by addr, on return it will contain the actual length (in bytes) of the address returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>the argument addr is a pointer to a sockaddr structure. This structure is filled in with the address of the peer socket, as known to the communications layer. The exact format of the address returned addr is determined by the socket's address<br/>
 sockaddr:<br/>
 - code for the address format. On this version only AF_INET is supported.<br/>
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addrlen</td><td>the addrlen argument is a value-result argument: it should initially contain the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket handle. On a non-blocking accept a possible negative value is SL_EAGAIN. On failure, negative value. SL_POOL_IS_EMPTY may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9" title="create an endpoint for communication ">sl_Socket</a> <a class="el" href="group__socket.html#ga45b5395b4b2bdd6189998849537c7d86" title="assign a name to a socket ">sl_Bind</a> <a class="el" href="group__socket.html#ga74ea071794a86d677212d6ae5041b923" title="listen for connections on a socket ">sl_Listen</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to server_side </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga45b5395b4b2bdd6189998849537c7d86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sl_Bind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assign a name to a socket </p>
<p>This function gives the socket the local address addr. addr is addrlen bytes long. Traditionally, this is called When a socket is created with socket, it exists in a name space (address family) but has no name assigned. It is necessary to assign a local address before a SOCK_STREAM socket may receive connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>specifies the destination addrs<br/>
 sockaddr:<br/>
 - code for the address format. On this version only AF_INET is supported.<br/>
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>contains the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, zero is returned. On error, a negative error code is returned.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9" title="create an endpoint for communication ">sl_Socket</a> <a class="el" href="group__socket.html#ga70d8c15542e4590d80cc9f9283f4b210" title="Accept a connection on a socket. ">sl_Accept</a> <a class="el" href="group__socket.html#ga74ea071794a86d677212d6ae5041b923" title="listen for connections on a socket ">sl_Listen</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to basic_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gabc776f15d8e8d8a4662269dac8aca1fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sl_Close </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gracefully close socket </p>
<p>This function causes the system to release resources allocated to a socket. <br/>
In case of TCP, the connection is terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>socket handle (received in sl_Socket)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, zero is returned. On error, a negative number is returned.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9" title="create an endpoint for communication ">sl_Socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to ext_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga2cc00ba87f0cd7cbdbfca14394502a15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sl_Connect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a connection on a socket. </p>
<p>Function connects the socket referred to by the socket descriptor sd, to the address specified by addr. The addrlen argument specifies the size of addr. The format of the address in addr is determined by the address space of the socket. If it is of type SOCK_DGRAM, this call specifies the peer with which the socket is to be associated; this address is that to which datagrams are to be sent, and the only address from which datagrams are to be received. If the socket is of type SOCK_STREAM, this call attempts to make a connection to another socket. The other socket is specified by address, which is an address in the communications space of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>specifies the destination addr<br/>
 sockaddr:<br/>
 - code for the address format. On this version only AF_INET is supported.<br/>
 - socket address, the length depends on the code format</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>contains the size of the structure pointed to by addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket handle. On a non-blocking connect a possible negative value is SL_EALREADY. On failure, negative value. SL_POOL_IS_EMPTY may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9" title="create an endpoint for communication ">sl_Socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to client_side </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gac2a4253cf994b2a796f730468abbe183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SL_FD_CLR </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *&#160;</td>
          <td class="paramname"><em>fdset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select's <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> CLR function. </p>
<p>Clears current socket descriptor on <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> container </p>

</div>
</div>
<a class="anchor" id="ga4de8eef8d39b4398d2e694dc88edd64e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SL_FD_ISSET </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *&#160;</td>
          <td class="paramname"><em>fdset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select's <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> ISSET function. </p>
<p>Checks if current socket descriptor is set (TRUE/FALSE)</p>
<dl class="section return"><dt>Returns</dt><dd>Returns TRUE if set, FALSE if unset </dd></dl>

</div>
</div>
<a class="anchor" id="ga25d4421250534b9bd4ac41b30f9cf06b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SL_FD_SET </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *&#160;</td>
          <td class="paramname"><em>fdset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select's <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> SET function. </p>
<p>Sets current socket descriptor on <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> container </p>

</div>
</div>
<a class="anchor" id="gac58eca56e2cf9bf58f8f3ef8790f7740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SL_FD_ZERO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *&#160;</td>
          <td class="paramname"><em>fdset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select's <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> ZERO function. </p>
<p>Clears all socket descriptors from <a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> </p>

</div>
</div>
<a class="anchor" id="ga43f04e75d9ea0a29b4a4c58f29cfdd8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sl_GetSockOpt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlSocklen_t *&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get socket options. </p>
<p>This function manipulate the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost socket level.</p>
<p>When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as SOL_SOCKET. To manipulate options at any other level the protocol number of the appropriate proto- col controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP;</p>
<p>The parameters optval and optlen are used to access optval - ues for setsockopt(). For getsockopt() they identify a buffer in which the value for the requested option(s) are to be returned. For getsockopt(), optlen is a value-result parameter, initially containing the size of the buffer pointed to by option_value, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, option_value may be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>defines the protocol level for this option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optname</td><td>defines the option name to interrogate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">optval</td><td>specifies a value for the option </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">optlen</td><td>specifies the length of the option value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, zero is returned. On error, a negative value is returned. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb" title="set socket options ">sl_SetSockOpt</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>See sl_SetSockOpt belongs to ext_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga56e74657a9772b9ad9e5ac5697d10562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long sl_Htonl </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder the bytes of a 32-bit unsigned value. </p>
<p>This function is used to Reorder the bytes of a 32-bit unsigned value from processor order to network order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var</td><td>variable to reorder</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the reorder variable,</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#ga0936b748a4f6d7f1943920ec91a82120" title="write data to socket ">sl_SendTo</a> <a class="el" href="group__socket.html#ga45b5395b4b2bdd6189998849537c7d86" title="assign a name to a socket ">sl_Bind</a> <a class="el" href="group__socket.html#ga2cc00ba87f0cd7cbdbfca14394502a15" title="Initiate a connection on a socket. ">sl_Connect</a> <a class="el" href="group__socket.html#gaee942befd4fa36fdacab25adfba2434b" title="read data from socket ">sl_RecvFrom</a> <a class="el" href="group__socket.html#ga70d8c15542e4590d80cc9f9283f4b210" title="Accept a connection on a socket. ">sl_Accept</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to send_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gada8288bc08f38860bd27cd5fd611e1ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short sl_Htons </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder the bytes of a 16-bit unsigned value. </p>
<p>This function is used to Reorder the bytes of a 16-bit unsigned value from processor order to network order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var</td><td>variable to reorder</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the reorder variable,</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#ga0936b748a4f6d7f1943920ec91a82120" title="write data to socket ">sl_SendTo</a> <a class="el" href="group__socket.html#ga45b5395b4b2bdd6189998849537c7d86" title="assign a name to a socket ">sl_Bind</a> <a class="el" href="group__socket.html#ga2cc00ba87f0cd7cbdbfca14394502a15" title="Initiate a connection on a socket. ">sl_Connect</a> <a class="el" href="group__socket.html#gaee942befd4fa36fdacab25adfba2434b" title="read data from socket ">sl_RecvFrom</a> <a class="el" href="group__socket.html#ga70d8c15542e4590d80cc9f9283f4b210" title="Accept a connection on a socket. ">sl_Accept</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to send_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga74ea071794a86d677212d6ae5041b923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sl_Listen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>listen for connections on a socket </p>
<p>The willingness to accept incoming connections and a queue limit for incoming connections are specified with listen(), and then the connections are accepted with accept. The listen() call applies only to sockets of type SOCK_STREAM The backlog parameter defines the maximum length the queue of pending connections may grow to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>socket descriptor (handle) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backlog</td><td>specifies the listen queue depth.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, zero is returned. On error, a negative error code is returned.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9" title="create an endpoint for communication ">sl_Socket</a> <a class="el" href="group__socket.html#ga70d8c15542e4590d80cc9f9283f4b210" title="Accept a connection on a socket. ">sl_Accept</a> <a class="el" href="group__socket.html#ga45b5395b4b2bdd6189998849537c7d86" title="assign a name to a socket ">sl_Bind</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to server_side </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga34256a8387b64d696c4a62ac1e282ee3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sl_Recv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read data from TCP socket </p>
<p>function receives a message from a connection-mode socket</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>socket handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Points to the buffer where the message should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Len</td><td>Specifies the length in bytes of the buffer pointed to by the buffer argument. Range: 1-16000 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message reception. On this version, this parameter is not supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the number of bytes received, or a negative value if an error occurred. using a non-blocking recv a possible negative value is SL_EAGAIN. SL_POOL_IS_EMPTY may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#gaee942befd4fa36fdacab25adfba2434b" title="read data from socket ">sl_RecvFrom</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to recv_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">An example of receiving data:</div>
<div class="line"></div>
<div class="line">           <a class="code" href="struct_sl_sock_addr_in__t.html">SlSockAddrIn_t</a>  Addr;</div>
<div class="line">           <a class="code" href="struct_sl_sock_addr_in__t.html">SlSockAddrIn_t</a>  LocalAddr;</div>
<div class="line">           <span class="keywordtype">int</span> AddrSize = <span class="keyword">sizeof</span>(<a class="code" href="struct_sl_sock_addr_in__t.html">SlSockAddrIn_t</a>);</div>
<div class="line">           <span class="keywordtype">int</span> SockID, newSockID;</div>
<div class="line">           <span class="keywordtype">int</span> Status;</div>
<div class="line">           <span class="keywordtype">char</span> Buf[RECV_BUF_LEN];</div>
<div class="line"></div>
<div class="line">           LocalAddr.sin_family = SL_AF_INET;</div>
<div class="line">           LocalAddr.sin_port = <a class="code" href="group__socket.html#gada8288bc08f38860bd27cd5fd611e1ba">sl_Htons</a>(5001);</div>
<div class="line">           LocalAddr.sin_addr.s_addr = 0;</div>
<div class="line"></div>
<div class="line">           Addr.sin_family = SL_AF_INET;</div>
<div class="line">           Addr.sin_port = <a class="code" href="group__socket.html#gada8288bc08f38860bd27cd5fd611e1ba">sl_Htons</a>(5001);</div>
<div class="line">           Addr.sin_addr.s_addr = <a class="code" href="group__socket.html#ga56e74657a9772b9ad9e5ac5697d10562">sl_Htonl</a>(SL_IPV4_VAL(10,1,1,200));</div>
<div class="line"></div>
<div class="line">           SockID = <a class="code" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9">sl_Socket</a>(SL_AF_INET,SL_SOCK_STREAM, 0);</div>
<div class="line">           Status = <a class="code" href="group__socket.html#ga45b5395b4b2bdd6189998849537c7d86">sl_Bind</a>(SockID, (<a class="code" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *)&amp;LocalAddr, AddrSize);</div>
<div class="line">           Status = <a class="code" href="group__socket.html#ga74ea071794a86d677212d6ae5041b923">sl_Listen</a>(SockID, 0);</div>
<div class="line">           newSockID = <a class="code" href="group__socket.html#ga70d8c15542e4590d80cc9f9283f4b210">sl_Accept</a>(SockID, (<a class="code" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a>*)&amp;Addr, (SlSocklen_t*) &amp;AddrSize);</div>
<div class="line">           Status = <a class="code" href="group__socket.html#ga34256a8387b64d696c4a62ac1e282ee3">sl_Recv</a>(newSockID, Buf, 1460, 0);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gaee942befd4fa36fdacab25adfba2434b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sl_RecvFrom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlSocklen_t *&#160;</td>
          <td class="paramname"><em>fromlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read data from socket </p>
<p>function receives a message from a connection-mode or connectionless-mode socket</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>socket handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Points to the buffer where the message should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Len</td><td>Specifies the length in bytes of the buffer pointed to by the buffer argument. Range: 1-16000 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message reception. On this version, this parameter is not supported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>pointer to an address structure indicating the source address.<br/>
 sockaddr:<br/>
 - code for the address format. On this version only AF_INET is supported.<br/>
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fromlen</td><td>source address structure size. This parameter MUST be set to the size of the structure pointed to by addr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the number of bytes received, or a negative value if an error occurred. using a non-blocking recv a possible negative value is SL_EAGAIN. SL_RET_CODE_INVALID_INPUT (-2) will be returned if fromlen has incorrect length. SL_POOL_IS_EMPTY may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#ga34256a8387b64d696c4a62ac1e282ee3" title="read data from TCP socket ">sl_Recv</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to recv_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">An example of receiving data:</div>
<div class="line"></div>
<div class="line">           <a class="code" href="struct_sl_sock_addr_in__t.html">SlSockAddrIn_t</a>  Addr;</div>
<div class="line">           <a class="code" href="struct_sl_sock_addr_in__t.html">SlSockAddrIn_t</a>  LocalAddr;</div>
<div class="line">           <span class="keywordtype">int</span> AddrSize = <span class="keyword">sizeof</span>(<a class="code" href="struct_sl_sock_addr_in__t.html">SlSockAddrIn_t</a>);</div>
<div class="line">           <span class="keywordtype">int</span> SockID;</div>
<div class="line">           <span class="keywordtype">int</span> Status;</div>
<div class="line">           <span class="keywordtype">char</span> Buf[RECV_BUF_LEN];</div>
<div class="line"></div>
<div class="line">           LocalAddr.sin_family = SL_AF_INET;</div>
<div class="line">           LocalAddr.sin_port = <a class="code" href="group__socket.html#gada8288bc08f38860bd27cd5fd611e1ba">sl_Htons</a>(5001);</div>
<div class="line">           LocalAddr.sin_addr.s_addr = 0;</div>
<div class="line"></div>
<div class="line">           SockID = <a class="code" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9">sl_Socket</a>(SL_AF_INET,SL_SOCK_DGRAM, 0);</div>
<div class="line">           Status = <a class="code" href="group__socket.html#ga45b5395b4b2bdd6189998849537c7d86">sl_Bind</a>(SockID, (<a class="code" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *)&amp;LocalAddr, AddrSize);</div>
<div class="line">           Status = <a class="code" href="group__socket.html#gaee942befd4fa36fdacab25adfba2434b">sl_RecvFrom</a>(SockID, Buf, 1472, 0, (<a class="code" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *)&amp;Addr, (SlSocklen_t*)&amp;AddrSize);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f5927fc693b19f6c1aab3110adc64b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sl_Select </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *&#160;</td>
          <td class="paramname"><em>readsds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *&#160;</td>
          <td class="paramname"><em>writesds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sl_fd_set__t.html">SlFdSet_t</a> *&#160;</td>
          <td class="paramname"><em>exceptsds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_sl_timeval__t.html">SlTimeval_t</a> *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Monitor socket activity. </p>
<p>Select allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become "ready" for some class of I/O operation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nfds</td><td>the highest-numbered file descriptor in any of the three sets, plus 1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">writesds</td><td>socket descriptors list for write monitoring </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">readsds</td><td>socket descriptors list for read monitoring </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exceptsds</td><td>socket descriptors list for exception monitoring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>is an upper bound on the amount of time elapsed before select() returns. Null or above 0xffff seconds means infinity timeout. The minimum timeout is 10 milliseconds, less than 10 milliseconds will be set automatically to 10 milliseconds. Max microseconds supported is 0xfffc00.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, select() returns the number of file descriptors contained in the three returned descriptor sets (that is, the total number of bits that are set in readfds, writefds, exceptfds) which may be zero if the timeout expires before anything interesting happens. On error, a negative value is returned. readsds - return the sockets on which Read request will return without delay with valid data. writesds - return the sockets on which Write request will return without delay. exceptsds - return the sockets closed recently. SL_POOL_IS_EMPTY may be return in case there are no resources in the system In this case try again later or increase MAX_CONCURRENT_ACTIONS</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9" title="create an endpoint for communication ">sl_Socket</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the timeout value set to less than 5ms it will automatically set to 5ms to prevent overload of the system belongs to basic_api</dd></dl>
<p>Only one sl_Select can be handled at a time. Calling this API while the same command is called from another thread, may result in one of the two scenarios:</p>
<ol type="1">
<li>The command will wait (internal) until the previous command finish, and then be executed.</li>
<li>There are not enough resources and SL_POOL_IS_EMPTY error will return. In this case, MAX_CONCURRENT_ACTIONS can be increased (result in memory increase) or try again later to issue the command.</li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga24dfb00de85356d4ba18662177c2eec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sl_Send </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write data to TCP socket </p>
<p>This function is used to transmit a message to another socket. Returns immediately after sending data to device. In case of TCP failure an async event SL_NETAPP_SOCKET_TX_FAILED is going to be received. In case of a RAW socket (transceiver mode), extra 4 bytes should be reserved at the end of the frame data buffer for WLAN FCS</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Points to a buffer containing the message to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Len</td><td>message size in bytes. Range: 1-1460 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message transmission. On this version, this parameter is not supported for TCP. For transceiver mode, the SL_RAW_RF_TX_PARAMS macro can be used to determine transmission parameters (channel,rate,tx_power,preamble)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the number of bytes transmitted, or -1 if an error occurred</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#ga0936b748a4f6d7f1943920ec91a82120" title="write data to socket ">sl_SendTo</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to send_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">An example of sending data:</div>
<div class="line"></div>
<div class="line">           <a class="code" href="struct_sl_sock_addr_in__t.html">SlSockAddrIn_t</a>  Addr;</div>
<div class="line">           <span class="keywordtype">int</span> AddrSize = <span class="keyword">sizeof</span>(<a class="code" href="struct_sl_sock_addr_in__t.html">SlSockAddrIn_t</a>);</div>
<div class="line">           <span class="keywordtype">int</span> SockID;</div>
<div class="line">           <span class="keywordtype">int</span> Status;</div>
<div class="line">           <span class="keywordtype">char</span> Buf[SEND_BUF_LEN];</div>
<div class="line"></div>
<div class="line">           Addr.sin_family = SL_AF_INET;</div>
<div class="line">           Addr.sin_port = <a class="code" href="group__socket.html#gada8288bc08f38860bd27cd5fd611e1ba">sl_Htons</a>(5001);</div>
<div class="line">           Addr.sin_addr.s_addr = <a class="code" href="group__socket.html#ga56e74657a9772b9ad9e5ac5697d10562">sl_Htonl</a>(SL_IPV4_VAL(10,1,1,200));</div>
<div class="line"></div>
<div class="line">           SockID = <a class="code" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9">sl_Socket</a>(SL_AF_INET,SL_SOCK_STREAM, 0);</div>
<div class="line">           Status = <a class="code" href="group__socket.html#ga2cc00ba87f0cd7cbdbfca14394502a15">sl_Connect</a>(SockID, (<a class="code" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *)&amp;Addr, AddrSize);</div>
<div class="line">           Status = <a class="code" href="group__socket.html#ga24dfb00de85356d4ba18662177c2eec5">sl_Send</a>(SockID, Buf, 1460, 0 );</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0936b748a4f6d7f1943920ec91a82120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sl_SendTo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlSocklen_t&#160;</td>
          <td class="paramname"><em>tolen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write data to socket </p>
<p>This function is used to transmit a message to another socket (connection less socket SOCK_DGRAM, SOCK_RAW). Returns immediately after sending data to device. In case of transmission failure an async event SL_NETAPP_SOCKET_TX_FAILED is going to be received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Points to a buffer containing the message to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Len</td><td>message size in bytes. Range: 1-1460 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies the type of message transmission. On this version, this parameter is not supported </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>pointer to an address structure indicating the destination address.<br/>
 sockaddr:<br/>
 - code for the address format. On this version only AF_INET is supported.<br/>
 - socket address, the length depends on the code format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolen</td><td>destination address structure size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the number of transmitted bytes, or -1 if an error occurred</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#ga24dfb00de85356d4ba18662177c2eec5" title="write data to TCP socket ">sl_Send</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to send_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">An example of sending data:</div>
<div class="line"></div>
<div class="line">           <a class="code" href="struct_sl_sock_addr_in__t.html">SlSockAddrIn_t</a>  Addr;</div>
<div class="line">           <span class="keywordtype">int</span> AddrSize = <span class="keyword">sizeof</span>(<a class="code" href="struct_sl_sock_addr_in__t.html">SlSockAddrIn_t</a>);</div>
<div class="line">           <span class="keywordtype">int</span> SockID;</div>
<div class="line">           <span class="keywordtype">int</span> Status;</div>
<div class="line">           <span class="keywordtype">char</span> Buf[SEND_BUF_LEN];</div>
<div class="line"></div>
<div class="line">           Addr.sin_family = SL_AF_INET;</div>
<div class="line">           Addr.sin_port = <a class="code" href="group__socket.html#gada8288bc08f38860bd27cd5fd611e1ba">sl_Htons</a>(5001);</div>
<div class="line">           Addr.sin_addr.s_addr = <a class="code" href="group__socket.html#ga56e74657a9772b9ad9e5ac5697d10562">sl_Htonl</a>(SL_IPV4_VAL(10,1,1,200));</div>
<div class="line"></div>
<div class="line">           SockID = <a class="code" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9">sl_Socket</a>(SL_AF_INET,SL_SOCK_DGRAM, 0);</div>
<div class="line">           Status = <a class="code" href="group__socket.html#ga0936b748a4f6d7f1943920ec91a82120">sl_SendTo</a>(SockID, Buf, 1472, 0, (<a class="code" href="struct_sl_sock_addr__t.html">SlSockAddr_t</a> *)&amp;Addr, AddrSize);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga173062c9a3a1ca728e651e98aedca7fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sl_SetSockOpt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SlSocklen_t&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set socket options </p>
<p>This function manipulate the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost socket level.</p>
<p>When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as SOL_SOCKET. To manipulate options at any other level the protocol number of the appropriate proto- col controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP;</p>
<p>The parameters optval and optlen are used to access optval - ues for setsockopt(). For getsockopt() they identify a buffer in which the value for the requested option(s) are to be returned. For getsockopt(), optlen is a value-result parameter, initially containing the size of the buffer pointed to by option_value, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, option_value may be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>socket handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>defines the protocol level for this option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optname</td><td>defines the option name to interrogate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optval</td><td>specifies a value for the option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optlen</td><td>specifies the length of the option value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, zero is returned. On error, a negative value is returned. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>sl_getsockopt </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to basic_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>
<dl class="section user"><dt>Examples:</dt><dd><div class="fragment"><div class="line">SL_SO_KEEPALIVE:</div>
<div class="line">   Keeps TCP connections active by enabling the periodic transmission of messages</div>
<div class="line">   Enable/Disable periodic keep alive.  </div>
<div class="line">   Default: Enabled, keep alive timeout 300 seconds.</div>
<div class="line">    </div>
<div class="line">   <a class="code" href="struct_sl_sock_keepalive__t.html">SlSockKeepalive_t</a> enableOption = 1;</div>
<div class="line">   <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(sd,SOL_SOCKET,SL_SO_KEEPALIVE, &amp;enableOption,<span class="keyword">sizeof</span>(enableOption));  <span class="comment">// Keeps connections active by enabling the periodic transmission of messages</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_SO_RCVTIMEO:</div>
<div class="line">   Sets the timeout value that specifies the maximum amount of time an input <span class="keyword">function</span> waits until it completes.</div>
<div class="line">   Default: No timeout</div>
<div class="line"></div>
<div class="line">   <span class="keyword">struct </span><a class="code" href="struct_sl_timeval__t.html">SlTimeval_t</a> timeval;</div>
<div class="line">   timeVal.tv_sec =  1;             <span class="comment">// Seconds</span></div>
<div class="line">   timeVal.tv_usec = 0;             <span class="comment">// Microseconds. 10000 microseconds resolution</span></div>
<div class="line">   <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(sd,SOL_SOCKET,SL_SO_RCVTIMEO, &amp;timeVal, <span class="keyword">sizeof</span>(timeVal));    <span class="comment">// Enable receive timeout </span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_SO_RCVBUF:</div>
<div class="line">       Sets tcp max recv window</div>
<div class="line"></div>
<div class="line">       <a class="code" href="struct_sl_sock_winsize__t.html">SlSockWinsize_t</a> size;</div>
<div class="line">       size = 3000;  <span class="comment">// bytes</span></div>
<div class="line">       <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(sd,SOL_SOCKET,SL_SO_RCVBUF, &amp;size, <span class="keyword">sizeof</span>(size));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_SO_NONBLOCKING:</div>
<div class="line">   Sets socket to non-blocking operation</div>
<div class="line">   Impact on: connect, accept, send, sendto, recv and recvfrom.</div>
<div class="line">   Default: Blocking.</div>
<div class="line"></div>
<div class="line">   <a class="code" href="struct_sl_sock_nonblocking__t.html">SlSockNonblocking_t</a> enableOption = 1;</div>
<div class="line">   <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(sd,SOL_SOCKET,SL_SO_NONBLOCKING, &amp;enableOption,<span class="keyword">sizeof</span>(enableOption)); <span class="comment">// Enable/disable nonblocking mode</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_SO_SECMETHOD + SL_SO_SECURE_MASK:</div>
<div class="line">   Sets method to tcp secured socket (SL_SEC_SOCKET)</div>
<div class="line">   Default: SL_SO_SEC_METHOD_SSLv3_TLSV1_2</div>
<div class="line"></div>
<div class="line">   <a class="code" href="struct_sl_sock_secure_method.html">SlSockSecureMethod</a> method;</div>
<div class="line">   method.secureMethod = SL_SO_SEC_METHOD_SSLV3;                                 <span class="comment">// security method we want to use</span></div>
<div class="line">   SockID = <a class="code" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9">sl_Socket</a>(SL_AF_INET,SL_SOCK_STREAM, SL_SEC_SOCKET);</div>
<div class="line">   <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_SOL_SOCKET, SL_SO_SEC_METHOD, &amp;method, sizeof(method));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_SO_SECURE_MASK:</div>
<div class="line">       Sets specific cipher to tcp secured socket (SL_SEC_SOCKET)</div>
<div class="line">       Default: &quot;Best&quot; cipher suitable to method</div>
<div class="line">       <a class="code" href="struct_sl_sock_secure_mask.html">SlSockSecureMask</a> cipher;</div>
<div class="line">       cipher.secureMask = SL_SEC_MASK_SSL_RSA_WITH_RC4_128_SHA;                   <span class="comment">// cipher type</span></div>
<div class="line">       SockID = <a class="code" href="group__socket.html#ga4808ad2f0d41a2b38b3d753ce3b3dfe9">sl_Socket</a>(SL_AF_INET,SL_SOCK_STREAM, SL_SEC_SOCKET);</div>
<div class="line">       <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_SOL_SOCKET, SL_SO_SEC_MASK, &amp;cipher, sizeof(cipher));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_SO_SECURE_FILES:</div>
<div class="line">       Map programmed files TCP secured socket (SL_SEC_SOCKET)</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structsock__secure_files.html">SlSockSecureFiles_t</a>   securedFiles;</div>
<div class="line">    securedFiles[SL_BSD_SECURED_PRIVATE_KEY_IDX] = [private key file index]</div>
<div class="line">    securedFiles[SL_BSD_SECURED_CERTIFICATE_IDX] = [secured certificate file index]</div>
<div class="line">    securedFiles[SL_BSD_SECURED_CA_IDX] = [secured CA file index]</div>
<div class="line">    securedFiles[SL_BSD_SECURED_DH_IDX] = [secured DH file index]</div>
<div class="line">    <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_SOL_SOCKET, SL_SO_SECURE_FILES, &amp;securedFiles[0], sizeof(<a class="code" href="structsock__secure_files.html">SlSockSecureFiles_t</a>));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_SO_CHANGE_CHANNEL:</div>
<div class="line">   sets channel in transceiver mode</div>
<div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newChannel = 6; <span class="comment">// range is 1-13</span></div>
<div class="line">   <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_SOL_SOCKET, SL_SO_CHANGE_CHANNEL, &amp;newChannel, <span class="keyword">sizeof</span>(newChannel));  </div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_IP_MULTICAST_TTL:</div>
<div class="line">      Set the time-to-live value of outgoing multicast packets <span class="keywordflow">for</span> <span class="keyword">this</span> socket</div>
<div class="line"></div>
<div class="line">      sets channel in transceiver mode</div>
<div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ttl = 20;</div>
<div class="line">      <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_IPPROTO_IP, SL_IP_MULTICAST_TTL, &amp;ttl, <span class="keyword">sizeof</span>(ttl));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_IP_RAW_RX_NO_HEADER:</div>
<div class="line">   Raw socket <span class="keyword">remove</span> IP header from received data.</div>
<div class="line">   Default: data includes ip header</div>
<div class="line"></div>
<div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> header = 1;  <span class="comment">// remove ip header</span></div>
<div class="line">   <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_IPPROTO_IP, SL_IP_RAW_RX_NO_HEADER, &amp;header, <span class="keyword">sizeof</span>(header));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_IP_HDRINCL:</div>
<div class="line">         RAW socket only, the IPv4 layer generates an IP header when sending a packet unless</div>
<div class="line">      the IP_HDRINCL socket option is enabled on the socket. When it is enabled, the packet must contain an IP header</div>
<div class="line">      Default: disabled, IPv4 header generated by Network Stack</div>
<div class="line"></div>
<div class="line">     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> header = 1;</div>
<div class="line">     <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_IPPROTO_IP, SL_IP_HDRINCL, &amp;header, <span class="keyword">sizeof</span>(header));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_IP_RAW_IPV6_HDRINCL:</div>
<div class="line">        RAW socket only, the IPv6 layer generates an IP header when sending a packet unless</div>
<div class="line">     the IP_HDRINCL socket option is enabled on the socket. When it is enabled, the packet must contain an IP header</div>
<div class="line">     Default: disabled, IPv4 header generated by Network Stack</div>
<div class="line"></div>
<div class="line">     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> header = 1;</div>
<div class="line">     <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_IPPROTO_IP, SL_IP_RAW_IPV6_HDRINCL, &amp;header, <span class="keyword">sizeof</span>(header));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_IP_ADD_MEMBERSHIP:</div>
<div class="line">    UDP socket, Join a multicast group</div>
<div class="line"></div>
<div class="line">    <a class="code" href="struct_sl_sock_ip_mreq.html">SlSockIpMreq</a> mreq;</div>
<div class="line">    <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_IPPROTO_IP, SL_IP_ADD_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(mreq));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_IP_DROP_MEMBERSHIP:</div>
<div class="line">    UDP socket, Leave a multicast group</div>
<div class="line"></div>
<div class="line">   <a class="code" href="struct_sl_sock_ip_mreq.html">SlSockIpMreq</a> mreq;</div>
<div class="line">   <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_IPPROTO_IP, SL_IP_DROP_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(mreq));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_SO_PHY_RATE:</div>
<div class="line">    RAW socket, set WLAN PHY transmit rate</div>
<div class="line"></div>
<div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> rate = 6; <span class="comment">// see wlan.h RateIndex_e for values</span></div>
<div class="line">   <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_RATE, &amp;rate, <span class="keyword">sizeof</span>(rate));  </div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_SO_PHY_TX_POWER:</div>
<div class="line">    RAW socket, set WLAN PHY TX power</div>
<div class="line"></div>
<div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> txpower = 1; <span class="comment">// valid range is 1-15</span></div>
<div class="line">   <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_TX_POWER, &amp;txpower, <span class="keyword">sizeof</span>(txpower));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_SO_PHY_NUM_FRAMES_TO_TX:</div>
<div class="line">    RAW socket, set number of frames to transmit in transceiver mode</div>
<div class="line"></div>
<div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> numframes = 1;</div>
<div class="line">   <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_NUM_FRAMES_TO_TX, &amp;numframes, <span class="keyword">sizeof</span>(numframes));</div>
</div><!-- fragment --> <div class="fragment"><div class="line">SL_SO_PHY_PREAMBLE:</div>
<div class="line">    RAW socket, set WLAN PHY preamble</div>
<div class="line"></div>
<div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> preamble = 1;</div>
<div class="line">   <a class="code" href="group__socket.html#ga173062c9a3a1ca728e651e98aedca7fb">sl_SetSockOpt</a>(SockID, SL_SOL_PHY_OPT, SL_SO_PHY_PREAMBLE, &amp;preamble, <span class="keyword">sizeof</span>(preamble));</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4808ad2f0d41a2b38b3d753ce3b3dfe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sl_Socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an endpoint for communication </p>
<p>The socket function creates a new socket of a certain socket type, identified by an integer number, and allocates system resources to it. This function is called by the application layer to obtain a socket handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>specifies the protocol family of the created socket. For example: AF_INET for network protocol IPv4 AF_RF for starting transceiver mode. Notes:<ul>
<li>sending and receiving any packet overriding 802.11 header</li>
<li>for optimized power consumption the socket will be started in TX only mode until receive command is activated AF_INET6 for IPv6</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>specifies the communication semantic, one of: SOCK_STREAM (reliable stream-oriented service or Stream Sockets) SOCK_DGRAM (datagram service or Datagram Sockets) SOCK_SEQPACKET (reliable sequenced packet service) SOCK_RAW (raw protocols atop the network layer) when used with AF_RF: SOCK_DGRAM - L2 socket SOCK_RAW - L1 socket - bypass WLAN CCA (Clear Channel Assessment)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>specifies a particular transport to be used with the socket. The most common are IPPROTO_TCP, IPPROTO_SCTP, IPPROTO_UDP, IPPROTO_DCCP. The value 0 may be used to select a default protocol from the selected domain and type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, socket handle that is used for consequent socket operations. A successful return code should be a positive number (int16) On error, a negative (int16) value will be returned specifying the error code. SL_EAFNOSUPPORT (-97) - illegal domain parameter SL_EPROTOTYPE (-91) - illegal type parameter SL_EACCES (-13) - permission denied SL_ENSOCK (-10) - exceeded maximal number of socket SL_ENOMEM (-12) - memory allocation error SL_NX_SOC_ERROR - resources allocation error SL_EINVAL (-22) - error in socket configuration SL_EPROTONOSUPPORT (-93) - illegal protocol parameter SL_EOPNOTSUPP (-95) - illegal combination of protocol and type parameters</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__socket.html#gabc776f15d8e8d8a4662269dac8aca1fc" title="gracefully close socket ">sl_Close</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>belongs to basic_api </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd></dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
